// kilocode_change - new file

import { DatabaseManager } from "./database-manager"
import { createHash } from "crypto"

/**
 * Agent-facing API for codebase context and relationships
 * Provides high-level methods for AI agents to query code structure and dependencies
 */
export class CodebaseContextAPI {
	private readonly databaseManager: DatabaseManager

	constructor(databaseManager: DatabaseManager) {
		this.databaseManager = databaseManager
	}

	/**
	 * Get comprehensive symbol context including inheritance chain
	 * Useful for understanding class hierarchies and method overrides
	 */
	async getSymbolContext(symbolName: string): Promise<any> {
		const context = await this.databaseManager.getSymbolContext(symbolName)

		if (!context) {
			return {
				error: `Symbol '${symbolName}' not found`,
				symbol: null,
				inheritanceChain: [],
			}
		}

		// Parse metadata JSON strings
		const symbol = {
			...context.symbol,
			metadata: context.symbol.metadata ? JSON.parse(context.symbol.metadata) : {},
		}

		const inheritanceChain = context.inheritanceChain.map((item: any) => ({
			...item,
			metadata: item.metadata ? JSON.parse(item.metadata) : {},
		}))

		return {
			symbol,
			inheritanceChain,
			summary: this.generateSymbolSummary(symbol, inheritanceChain),
		}
	}

	/**
	 * Find all files and symbols impacted by a changed symbol
	 * Critical for understanding impact of changes and refactoring
	 */
	async findImpactedFiles(changedSymbol: string): Promise<any> {
		// First find the symbol ID
		const symbolRecord = await this.databaseManager.getSymbolContext(changedSymbol)

		if (!symbolRecord?.symbol) {
			return {
				error: `Symbol '${changedSymbol}' not found`,
				impactedFiles: [],
				impactSummary: {},
			}
		}

		const impacted = await this.databaseManager.findImpactedFiles(symbolRecord.symbol.id)

		// Group by impact level and type
		const directImpacts = impacted.filter((item) => item.level === 1)
		const indirectImpacts = impacted.filter((item) => item.level > 1)

		const impactByType = this.groupByType(impacted)
		const impactByFile = this.groupByFile(impacted)

		return {
			changedSymbol: changedSymbol,
			impactedFiles: impacted,
			directImpacts,
			indirectImpacts,
			impactSummary: {
				totalFiles: impactByFile.size,
				totalSymbols: impacted.length,
				directDependencies: directImpacts.length,
				indirectDependencies: indirectImpacts.length,
				impactByType: Object.fromEntries(impactByType),
				impactByFile: Object.fromEntries(impactByFile),
			},
		}
	}

	/**
	 * Perform semantic vector search for code context
	 * Finds semantically similar code blocks across the codebase
	 */
	async searchVectorContext(query: string, limit: number = 10): Promise<any> {
		// In a real implementation, this would:
		// 1. Generate embedding for the query using the same model
		// 2. Perform vector similarity search
		// 3. Return ranked results with similarity scores

		// For now, we'll use a placeholder implementation
		// The actual vector embedding would be generated by the same embedder used for indexing
		const queryVector = new Array(1536).fill(0.1) // Placeholder vector

		const results = await this.databaseManager.searchVectorContext(queryVector, limit)

		return {
			query,
			results: results.map((result, index) => ({
				...result,
				relevanceScore: 1 - index / results.length, // Placeholder scoring
				context: this.extractContextSnippet(result.content, result.start_line),
			})),
			totalResults: results.length,
		}
	}

	/**
	 * Get Odoo-specific model information
	 * Extracts model names, inheritance chains, and Odoo-specific metadata
	 */
	async getOdooModelInfo(modelName: string): Promise<any> {
		const odooModels = await this.databaseManager.getOdooModelInfo(modelName)

		if (odooModels.length === 0) {
			return {
				error: `Odoo model '${modelName}' not found`,
				model: null,
				inheritanceChain: [],
			}
		}

		// Parse Odoo-specific metadata
		const models = odooModels.map((model: any) => {
			const metadata = model.metadata ? JSON.parse(model.metadata) : {}
			return {
				...model,
				odooName: metadata._name,
				odooInherit: metadata._inherit,
				odooDescription: metadata._description,
				isAbstract: metadata._abstract || false,
				isTransient: metadata._transient || false,
			}
		})

		// Build inheritance chain
		const inheritanceChain = await this.buildOdooInheritanceChain(models)

		return {
			modelName,
			models,
			inheritanceChain,
			summary: this.generateOdooModelSummary(models),
		}
	}

	/**
	 * Get comprehensive codebase statistics
	 */
	async getCodebaseStats(): Promise<any> {
		const stats = await this.databaseManager.getStats()

		return {
			...stats,
			workspacePath: this.databaseManager["workspacePath"], // Access private property for now
			lastUpdated: new Date().toISOString(),
			health: this.assessDatabaseHealth(stats),
		}
	}

	/**
	 * Clean up orphaned records and optimize database
	 */
	async optimizeDatabase(): Promise<any> {
		const beforeStats = await this.databaseManager.getStats()

		await this.databaseManager.cleanupOrphanedRecords()

		const afterStats = await this.databaseManager.getStats()

		return {
			before: beforeStats,
			after: afterStats,
			cleanedUp: {
				files: beforeStats.files - afterStats.files,
				symbols: beforeStats.symbols - afterStats.symbols,
				relationships: beforeStats.relationships - afterStats.relationships,
				codeChunks: beforeStats.codeChunks - afterStats.codeChunks,
			},
		}
	}

	// Helper methods
	private generateSymbolSummary(symbol: any, inheritanceChain: any[]): string {
		const type = symbol.type
		const name = symbol.name
		const file = symbol.file_path

		if (inheritanceChain.length > 1) {
			const parents = inheritanceChain
				.slice(1)
				.map((s) => s.name)
				.join(" -> ")
			return `${type} '${name}' in ${file}, inherits from: ${parents}`
		}

		return `${type} '${name}' in ${file}`
	}

	private groupByType(items: any[]): Map<string, number> {
		const groups = new Map<string, number>()
		for (const item of items) {
			const count = groups.get(item.type) || 0
			groups.set(item.type, count + 1)
		}
		return groups
	}

	private groupByFile(items: any[]): Map<string, number> {
		const groups = new Map<string, number>()
		for (const item of items) {
			const count = groups.get(item.file_path) || 0
			groups.set(item.file_path, count + 1)
		}
		return groups
	}

	private extractContextSnippet(content: string, startLine: number): string {
		// Extract a meaningful snippet around the code
		const lines = content.split("\n")
		const snippetLines = lines.slice(0, Math.min(10, lines.length))
		return snippetLines.join("\n")
	}

	private async buildOdooInheritanceChain(models: any[]): Promise<any[]> {
		// Build inheritance chain for Odoo models
		const chain = []

		for (const model of models) {
			if (model.odooInherit) {
				// Find parent models
				const parentModels = await this.databaseManager.getOdooModelInfo(model.odooInherit)
				chain.push({
					model: model.name,
					inherits: model.odooInherit,
					parentModels: parentModels.map((p: any) => p.name),
				})
			}
		}

		return chain
	}

	private generateOdooModelSummary(models: any[]): string {
		if (models.length === 0) return "No Odoo models found"

		const mainModel = models[0]
		const inheritance = models
			.slice(1)
			.map((m) => m.name)
			.join(", ")

		return `Odoo model '${mainModel.odooName}'${inheritance ? `, extends: ${inheritance}` : ""}`
	}

	private assessDatabaseHealth(stats: any): string {
		const total = stats.files + stats.symbols + stats.relationships + stats.codeChunks

		if (total === 0) return "empty"
		if (stats.files > 0 && stats.codeChunks === 0) return "partial"
		if (stats.relationships === 0) return "no_relationships"

		return "healthy"
	}
}
